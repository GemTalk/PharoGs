PackageManifest subclass: #ManifestPharoGs	instanceVariableNames: ''	classVariableNames: ''	package: 'PharoGs-Manifest'!!ManifestPharoGs commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManifestPharoGs class	instanceVariableNames: ''!!ManifestPharoGs class methodsFor: 'code-critics' stamp: 'JamesFoster 7/16/2019 08:12'!ruleRBCodeCruftLeftInMethodsRuleV1FalsePositive	^ #(#(#(#RGPackageDefinition #(#PharoGs)) #'2019-07-16T08:12:30.933457-07:00') )! !!ManifestPharoGs class methodsFor: 'code-critics' stamp: 'JamesFoster 7/16/2019 08:48'!ruleFloatReferencesRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PharoGsExport #pharoToGsClassMap #false)) #'2019-07-16T08:48:17.324327-07:00') )! !!ManifestPharoGs class methodsFor: 'code-critics' stamp: 'JamesFoster 7/16/2019 08:20'!ruleRBCascadedNextPutAllsRuleV1FalsePositive	^ #(#(#(#RGPackageDefinition #(#PharoGs)) #'2019-07-16T08:20:25.643541-07:00') )! !!ManifestPharoGs class methodsFor: 'code-critics' stamp: 'JamesFoster 7/16/2019 08:20'!ruleRBUtilityMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PharoGsExport #createMissingInstVarsAsGlobalsIn: #false)) #'2019-07-16T08:20:52.291696-07:00') )! !!ManifestPharoGs class methodsFor: 'code-critics' stamp: 'JamesFoster 7/16/2019 09:30'!ruleRBUsesAddRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PharoGsExport #listOfClasses #false)) #'2019-07-16T09:30:48.65773-07:00') )! !!ManifestPharoGs class methodsFor: 'code-critics' stamp: 'JamesFoster 7/16/2019 08:19'!ruleRBYourselfNotUsedRuleV1FalsePositive	^ #(#(#(#RGPackageDefinition #(#PharoGs)) #'2019-07-16T08:19:15.840946-07:00') )! !Object subclass: #PharoGsExport	instanceVariableNames: 'fileStream'	classVariableNames: ''	package: 'PharoGs'!!PharoGsExport commentStamp: 'JamesFoster 7/16/2019 08:08' prior: 0!I export Pharo code in a format that can be loaded into GemStone/S.!!PharoGsExport methodsFor: 'export' stamp: 'JamesFoster 7/16/2019 13:37'!createGlobals	| dict |	dict := Smalltalk globals reject: [ :each | each isBehavior or: [each == Smalltalk]].	fileStream		nextPutAll: '!! - create Pharo globals'; lf;		nextPutAll: 'run'; lf;		nextPutAll: 'Smalltalk'; lf.	dict keys asSortedCollection do: [:eachKey | 		fileStream 			tab; nextPutAll: 'at: #'; 			nextPutAll: eachKey; 			nextPutAll: ' put: nil;';			lf.	].	fileStream 		tab; nextPutAll: 'at: #superclass put: nil;'; lf;		tab; nextPutAll: 'at: #thisContext put: nil;'; lf;		"tab; nextPutAll: 'at: #Color put: nil;'; lf;		tab; nextPutAll: 'at: #ColorMap put: nil;'; lf;		tab; nextPutAll: 'at: #ImageReadWriter put: nil;'; lf;		tab; nextPutAll: 'at: #MailAddressParser put: nil;'; lf;		tab; nextPutAll: 'at: #MailMessage put: nil;'; lf;		tab; nextPutAll: 'at: #STON put: nil;'; lf;"		yourself.	self createMissingInstVarsAsGlobals.	fileStream		tab; nextPutAll: 'yourself.'; lf;		nextPut: $%; lf;		nextPutAll: 'errorCount'; lf;		yourself.	Transcript show: 'globals count = ' , dict size printString; cr.! !!PharoGsExport methodsFor: 'export' stamp: 'JamesFoster 7/16/2019 09:08'!createPools	| pools |	fileStream nextPutAll: '!! - create Pharo Pools'; lf.	pools := IdentitySet new.	ProtoObject withAllSubclasses do: [:eachClass | 		pools addAll: eachClass sharedPools.	].	pools := pools asSortedCollection: [:a :b | a name <= b name].	pools do: [:eachSharedPool | 		fileStream 			nextPutAll: 'run'; lf;			nextPutAll: '(PharoPools at: #';			nextPutAll: eachSharedPool name;			nextPutAll: ' ifAbsentPut: [SymbolDictionary new name: #';			nextPutAll: eachSharedPool name;			nextPutAll: '])'; 			lf.		eachSharedPool classPool keys asSortedCollection do: [:eachKey | 			fileStream				tab; nextPutAll: 'at: #'; 				nextPutAll: eachKey; 				nextPutAll: ' ifAbsentPut: [nil];'; lf.		].		fileStream tab; nextPutAll: 'yourself.'; lf; nextPut: $%; lf.	].	fileStream nextPutAll: 'errorCount'; lf.	Transcript show: 'pools count = ' , pools size printString; cr.! !!PharoGsExport methodsFor: 'export' stamp: 'JamesFoster 7/16/2019 09:03'!installPackages	"Extra (or replacement) packages we want to be in GemStone"		| list |	list := OrderedCollection new		"Extra packages to add to GemStone"		add: '/Users/jfoster/code/pharo/src/' -> 'Monticello';	   add: '/Users/jfoster/code/pharo/src/' -> 'SUnit-Core';	   add: '/Users/jfoster/code/pharo/src/' -> 'Kernel-Tests';		"Edited packages to load from the checkout (not yet in a bootstrap image) can be added as well"	   yourself.	list do: [:each | | reader |	    Transcript nextPutAll: 'Installing '; nextPutAll: each value; cr.	    reader := TonelReader 	        on: each key asFileReference	        fileName: each value.	    (MCSnapshot fromDefinitions: reader definitions) install.	].! !!PharoGsExport methodsFor: 'export' stamp: 'JamesFoster 7/16/2019 12:52'!doExport	[ 		self 			installPackages;			openFile;			createGlobals;			createPools;			createClasses;			createMethods;			closeFile;			yourself.	] on: Error do: [:ex | 		Transcript show: ex description; cr.		ex signalerContext stack do: [:each |			Transcript show: each; cr.		].	].! !!PharoGsExport methodsFor: 'export' stamp: 'JamesFoster 7/16/2019 12:53'!closeFile	fileStream 		nextPutAll: 'errorCount'; lf;		nextPutAll: 'output pop'; lf;		nextPutAll: 'errorCount'; lf;		close.		! !!PharoGsExport methodsFor: 'export' stamp: 'JamesFoster 7/16/2019 08:59'!createMissingInstVarsAsGlobals	fileStream 		tab; nextPutAll: 'at: #lookupClass put: #Message;'; lf;		tab; nextPutAll: 'at: #quiescentProcessLists put: #ProcessorScheduler;'; lf;		tab; nextPutAll: 'at: #exceptions put: #ExceptionSet;'; lf;		tab; nextPutAll: 'at: #startpc put: #BlockClosure;'; lf;		tab; nextPutAll: 'at: #numArgs put: #BlockClosure;'; lf;		tab; nextPutAll: 'at: #outerContext put: #BlockClosure;'; lf;		tab; nextPutAll: 'at: #signalContext put: #Exception;'; lf;		tab; nextPutAll: 'at: #handlerContext put: #Exception;'; lf;		tab; nextPutAll: 'at: #outerContext put: #Exception;'; lf;		tab; nextPutAll: 'at: #signaler put: #Exception;'; lf;		tab; nextPutAll: 'at: #layout put: #Behavior;'; lf;		tab; nextPutAll: 'at: #methodDict put: #Exception;'; lf;		tab; nextPutAll: 'at: #startpc put: #FullBlockClosure;'; lf;		tab; nextPutAll: 'at: #outerContext put: #FullBlockClosure;'; lf;		tab; nextPutAll: 'at: #numArgs put: #FullBlockClosure;'; lf;		tab; nextPutAll: 'at: #signalContext put: #Halt;'; lf;		tab; nextPutAll: 'at: #organization put: #ClassDescription;'; lf;		tab; nextPutAll: 'at: #layout put: #ClassDescription;'; lf;		tab; nextPutAll: 'at: #reachedDefaultHandler put: #MessageNotUnderstood;'; lf;		tab; nextPutAll: 'at: #message put: #MessageNotUnderstood;'; lf;		tab; nextPutAll: 'at: #result put: #CannotReturn;'; lf;		tab; nextPutAll: 'at: #category put: #Class;'; lf;		tab; nextPutAll: 'at: #localSelectors put: #Class;'; lf;		tab; nextPutAll: 'at: #classPool put: #Class;'; lf;		tab; nextPutAll: 'at: #sharedPools put: #Class;'; lf;		tab; nextPutAll: 'at: #environment put: #Class;'; lf;		tab; nextPutAll: 'at: #traitComposition put: #Class;'; lf;		tab; nextPutAll: 'at: #thisClass put: #Metaclass;'; lf;		tab; nextPutAll: 'at: #localSelectors put: #Metaclass;'; lf;		tab; nextPutAll: 'at: #traitComposition put: #Metaclass;'; lf;		tab; nextPutAll: 'at: #CaseSensitiveOrder put: #ByteSymbol;'; lf;		yourself.! !!PharoGsExport methodsFor: 'export' stamp: 'JamesFoster 7/16/2019 10:40'!openFile	fileStream := 'PharoGs.tpz' asFileReference writeStream		nextPutAll: 'errorCount'; lf;		nextPutAll: 'output push PharoGs.out only'; lf;		nextPutAll: 'errorCount'; lf;		yourself.! !!PharoGsExport methodsFor: 'classes' stamp: 'JamesFoster 7/16/2019 12:15'!pharoToGsClassMap	^Dictionary new 		at: Array 						put: #Array;		at: Behavior 					put: #Behavior;		at: BlockClosure 				put: #BlockClosure;		at: Boolean 						put: #Boolean;		at: ByteArray 					put: #ByteArray;		at: CannotReturn 				put: #CannotReturn;		at: Character 					put: #Character;		at: Class 						put: #Class;		at: Collection 					put: #Collection;		at: Exception 					put: #Exception;		at: ExceptionSet 				put: #ExceptionSet;		at: FloatingPointException 	put: #FloatingPointException;		at: Integer 						put: #Integer;		at: LargeInteger 				put: #LargeInteger;		at: Magnitude 					put: #Magnitude;		at: Message 						put: #Message;		at: MessageNotUnderstood 	put: #MessageNotUnderstood;		at: Notification 				put: #Notification;		at: Number 						put: #Number;		at: Object 						put: #Object;		at: Pragma 						put: #Pragma;		at: ProcessorScheduler 		put: #ProcessorScheduler;		at: Semaphore 					put: #Semaphore;		at: SequenceableCollection 	put: #SequenceableCollection;		at: SmallInteger 				put: #SmallInteger;		at: String 						put: #String;		at: Symbol 						put: #Symbol;		at: UndefinedObject 			put: #UndefinedObject;		at: Warning 						put: #Warning;		at: ZeroDivide 					put: #ZeroDivide;		at: ArithmeticError 			put: #NumericError;		at: BoxedFloat64 				put: #Float;		at: ByteString 					put: #String;		at: ByteSymbol 					put: #Symbol;		at: ClassDescription 			put: #Module;		at: Float 						put: #BinaryFloat;		at: Metaclass 					put: #Metaclass3;		at: MethodDictionary 			put: #GsMethodDictionary;		at: ScaledDecimal 				put: #FixedPoint;		at: SmallFloat64 				put: #SmallDouble;		at: WideString 					put: #QuadByteString;		at: WideSymbol 					put: #QuadByteSymbol;		yourself! !!PharoGsExport methodsFor: 'classes' stamp: 'JamesFoster 7/16/2019 10:11'!defineClassVarsFor: aClass	fileStream tab; nextPutAll: 'classVars: #('.	aClass classVarNames do: [ :each | 		fileStream space; nextPutAll: each.	].	fileStream nextPut: $); lf.! !!PharoGsExport methodsFor: 'classes' stamp: 'JamesFoster 7/16/2019 10:14'!addClassFor: aClass	"create a new class to represent the Pharo class"	| instSpec isBytes message superclass |	instSpec := aClass instSpec.	isBytes := false.	"determine the subclass type (byte, indexable, or objects"	message := ((superclass := aClass superclass) notNil		and: [ superclass instSpec ~~ instSpec ])		ifTrue: [ 			(instSpec between: 16 and: 23) ifTrue: [ 				isBytes := true.				' byteSubclass: ''' 			] ifFalse: [				(instSpec between: 2 and: 4)					ifTrue: [ ' indexableSubclass: ''' ]					ifFalse: [ ' subclass: ''' ].			]		] ifFalse: [ 			' subclass: ''' 		].	fileStream		nextPutAll: 'errorCount'; lf;		nextPutAll: 'run'; lf;		nextPut: $(;		nextPutAll: (self nameForSuperclass: superclass);		nextPutAll: message;		nextPutAll: aClass name;		nextPut: $';		lf.	isBytes ifFalse: [ 		self defineInstVarsFor: aClass.	].	self 		defineClassVarsFor: aClass;		defineClassInstVarsFor: aClass;		definePoolsFor: aClass;		yourself.	fileStream		tab; nextPutAll: 'inDictionary: Smalltalk'; lf;		tab; nextPutAll: 'newVersionOf: (Smalltalk at: #';			nextPutAll: aClass name;			nextPutAll: ' ifAbsent: [nil])'; lf;		tab; nextPutAll: 'description: '''; print: aClass instSpec; nextPut: $'; lf;		tab; nextPutAll: 'options: #()'; lf;		nextPutAll: ') category: '''; nextPutAll: aClass category; nextPutAll: '''.'; lf;		nextPut: $%; lf;		yourself.		! !!PharoGsExport methodsFor: 'classes' stamp: 'JamesFoster 7/16/2019 12:07'!defineClassInstVarsFor: aClass	fileStream tab; nextPutAll: 'classInstVars: #('.	aClass class instVarNames do: [ :each | 		fileStream space; nextPutAll: each.	].	fileStream nextPut: $); lf.	! !!PharoGsExport methodsFor: 'classes' stamp: 'JamesFoster 7/16/2019 09:49'!addClassVarsFor: aClass	"We have an identical class in GemStone but it might not have the desired class variables"	aClass class classVarNames isEmpty ifTrue: [ ^self ].	fileStream		nextPutAll: 'errorCount'; lf;		nextPutAll: 'run'; lf;		nextPutAll: '| names |'; lf;		nextPutAll: 'names := #(';		yourself.	"add any Pharo class variable names to the GemStone class"	aClass classVarNames do: [ :each | 			fileStream space; nextPutAll: each.	].	aClass class notNil ifTrue: [ 		aClass class instVarNames do: [ :each | 			fileStream space; nextPutAll: each. 		]	].	fileStream		nextPutAll: ').'; lf;		nextPutAll: 'names do: [:each | '; lf;		tab; nextPut: $(;		nextPutAll: aClass name;		nextPutAll: ' classVarNames includes: each) ifFalse: ['; lf;		tab; tab; nextPutAll: aClass name; nextPutAll: ' addClassVarName: each]].'; lf;		nextPut: $%; lf;		yourself.! !!PharoGsExport methodsFor: 'classes' stamp: 'JamesFoster 7/16/2019 12:49'!createClasses	| list |	self		createLinksToIdenticalClasses;		createNoSubclassesClass;		yourself.	list := self listOfClasses.	list do: [ :aClass | 		(self pharoToGsClassMap keys includes: aClass) ifTrue: [ 			"we are using the GemStone class, so should not create a new class"			self addClassVarsFor: aClass.		] ifFalse: [ 			"create a new class"			self addClassFor: aClass.		].		fileStream flush.	].	fileStream nextPutAll: 'errorCount'; lf.	Transcript show: 'classes count = ' , list size printString; cr.! !!PharoGsExport methodsFor: 'classes' stamp: 'JamesFoster 7/16/2019 12:36'!listOfClasses	| list queue |	queue := OrderedCollection with: ProtoObject.	list := queue copy.	[ queue notEmpty ] whileTrue: [ 		| next |		next := queue removeFirst.		queue addAll: (list addAll: (next subclasses asSortedCollection: [:a :b | a name <= b name])).	].	^list reject: [:each | each isMeta or: [#(ManifestPharoGs PharoGsExport) includes: each name]]! !!PharoGsExport methodsFor: 'classes' stamp: 'JamesFoster 7/16/2019 10:12'!definePoolsFor: aClass	fileStream		tab; nextPutAll: 'poolDictionaries: {'.	aClass sharedPools do: [ :each | 		fileStream space; nextPutAll: each name; nextPutAll: '. '.	].	fileStream nextPut: $}; lf.	! !!PharoGsExport methodsFor: 'classes' stamp: 'JamesFoster 7/16/2019 09:56'!nameForSuperclass: aClass	aClass ifNil: [ ^'nil' ].	"some of the Pharo classes are subclasses of GemStone classes that don't allow subclassing"	^(#(Behavior BlockClosure Boolean Class ExceptionSet LargeInteger Symbol) includes: aClass name)		ifTrue: [ 'NoSubclasses' ]		ifFalse: [ aClass name ]! !!PharoGsExport methodsFor: 'classes' stamp: 'JamesFoster 7/16/2019 11:46'!createLinksToIdenticalClasses	fileStream		nextPutAll: '!! - create links to identical classes'; lf;		nextPutAll: 'errorCount'; lf;		nextPutAll: 'run'; lf;		nextPutAll: 'Smalltalk'; lf;		yourself.	self pharoToGsClassMap keysAndValuesDo: [:eachKey :eachValue | 		fileStream 			tab; nextPutAll: 'at: #'; nextPutAll: eachKey name; 			nextPutAll: ' put: (Globals at: #'; nextPutAll: eachValue;			nextPutAll: ');'; lf;			yourself.	].	fileStream lf;		tab; nextPutAll: 'yourself.'; lf;		nextPut: $%; lf;		nextPutAll: 'errorCount'; lf;		yourself.! !!PharoGsExport methodsFor: 'classes' stamp: 'JamesFoster 7/16/2019 11:50'!defineInstVarsFor: aClass	fileStream tab; nextPutAll: 'instVarNames: #('.	aClass instVarNames do: [ :each | 		fileStream space; nextPutAll: each.	].	fileStream nextPut: $); lf.! !!PharoGsExport methodsFor: 'classes' stamp: 'JamesFoster 7/16/2019 09:18'!createNoSubclassesClass	fileStream		nextPutAll: 'run'; lf;		nextPutAll: '(Object subclass: ''NoSubclasses'''; lf;		tab; nextPutAll: 'instVarNames: #()'; lf;		tab; nextPutAll: 'classVars: #()'; lf;		tab; nextPutAll: 'classInstVars: #()'; lf;		tab; nextPutAll: 'poolDictionaries: {}'; lf;		tab; nextPutAll: 'inDictionary: Smalltalk'; lf;		tab; nextPutAll: 'newVersionOf: (Smalltalk at: #NoSubclasses ifAbsent: [nil])'; lf;		tab; nextPutAll: 'description: ''0'''; lf;		tab; nextPutAll: 'options: #()'; lf;		tab; nextPutAll: ') category: ''GemStone''.'; lf;		nextPut: $%; lf;		yourself.! !!PharoGsExport methodsFor: 'methods' stamp: 'JamesFoster 7/16/2019 10:24'!replaceCrWithLfIn: aString	^aString collect: [:each | 		each == Character cr ifTrue: [Character lf] ifFalse: [each].	]! !!PharoGsExport methodsFor: 'methods' stamp: 'JamesFoster 7/16/2019 12:31'!createMethods	| count |	Transcript show: 'method count = '.	count := 0.	fileStream		nextPutAll: '!! - generate methods'; lf;		nextPutAll: 'errorCount'; lf;		nextPutAll: 'set compile_env: 0'; lf;		nextPutAll: 'run'; lf;		nextPutAll: '| symbolList |'; lf;		nextPutAll: 'symbolList := GsSession currentSession symbolList.'; lf;		nextPutAll: 'symbolList add: (symbolList remove: PharoPools) after: Smalltalk.'; lf;		nextPut: $%; lf.	self listOfClasses do: [:aClass | 		count := count + (self createMethodsFor: aClass).	].	fileStream  nextPutAll: 'errorCount'; lf.	Transcript show: count printString; cr.! !!PharoGsExport methodsFor: 'methods' stamp: 'JamesFoster 7/16/2019 11:04'!rewritePrimitiveIn: aString	| i source |	source := aString.	"special handling of primitives"	i := source findString: '<primitive:'.	0 < i ifTrue: [ | string inComment inString |		inComment := false.		inString := false.		(string := source copyFrom: 1 to: i - 1) do: [:char | 			char == $" ifTrue: [inComment := inComment not].			(inComment not and: [char == $']) ifTrue: [inString := inString not].		].		(inComment not and: [inString not]) ifTrue: [			source := string , '<PharoPrimitive>' , Character lf asString , 				'self @env0:error: ''PharoPrimitive''.' , Character lf asString ,				'"' , Character tab asString , 				((source copyFrom: i to: source size) copyReplaceAll: '"' with: '""') , 				'"'.		].	].	^source! !!PharoGsExport methodsFor: 'methods' stamp: 'JamesFoster 7/16/2019 10:29'!fixBinarySelectorsInLiteralArrayIn: aString	| literalArrayDepth prev readStream writeStream |	prev := nil.	literalArrayDepth := 0.	readStream := ReadStream on: aString.	writeStream := WriteStream on: String new.	[		readStream atEnd.	] whileFalse: [		| next |		next := readStream next.				"deal with comments"		(next == $" and: [prev ~~ $$]) ifTrue: [			writeStream nextPut: $"; nextPutAll: (readStream upTo: $"); nextPut: $".			prev := $".		] ifFalse: [			"deal with strings"		(next == $' and: [prev ~~ $$]) ifTrue: [			writeStream nextPut: $'; nextPutAll: (readStream upTo: $'); nextPut: $'.			prev := $'.		] ifFalse: [				"deal with start of literal Array"		(next == $# and: [readStream peekFor: $(]) ifTrue: [			writeStream nextPutAll: '#('.			prev := $(.			literalArrayDepth := literalArrayDepth + 1.		] ifFalse: [			"here we are inside a literal array"		literalArrayDepth > 0 ifTrue: [				"a nested literal array"			(next == $( and: [prev ~~ $# and: [prev ~~ $$]]) ifTrue: [				writeStream nextPutAll: '#('.				prev := next.				literalArrayDepth := literalArrayDepth + 1.			] ifFalse: [				"end of a literal array"			next == $) ifTrue: [				writeStream nextPut: next.				prev := next.				literalArrayDepth := literalArrayDepth - 1.			] ifFalse: [						"handle binary selectors (this is why we are doing the work)"			(next isSpecial and: [prev ~~ $$]) ifTrue: [				prev ~~ $# ifTrue: [					writeStream nextPutAll: ' #'.					prev := $#.				].				writeStream nextPut: next.				prev := next.				[					readStream peek isSpecial.				] whileTrue: [					writeStream nextPut: (prev := readStream next).				].						"other characters inside a literal array"			] ifFalse: [				writeStream nextPut: next.				prev := next.			]]]			"other characters outside of a literal array"		] ifFalse: [			writeStream nextPut: next.			prev := next.		]]]]	].	^writeStream contents.! !!PharoGsExport methodsFor: 'methods' stamp: 'JamesFoster 7/16/2019 11:01'!createMethodsFor: aClass	| count path savedStream |	count := 0.	aClass isMeta ifTrue: [^count].	"generate file-in for methods"	path := 'classes/' , aClass name , '.gs'.	fileStream nextPutAll: 'input '; nextPutAll: path; lf.	savedStream := fileStream.	[ 		fileStream := path asFileReference writeStream.		self 			addMethodsHeaderFor: aClass;			addClassCommentFor: aClass;			yourself.		count := count + (self addMethodsFor: aClass).		count := count + (self addMethodsFor: aClass class).		fileStream 			nextPutAll: 'set compile_env: 0'; lf;			nextPutAll: 'errorCount'; lf;			nextPutAll: 'output pop'; lf;			nextPutAll: 'errorCount'; lf;			close.	] ensure: [ 		fileStream := savedStream.	].	^count	! !!PharoGsExport methodsFor: 'methods' stamp: 'JamesFoster 7/16/2019 11:09'!rewriteReservedSelectorsIn: aString selector: eachSelector	| source |	(self reservedSelectors includes: eachSelector) ifFalse: [ ^aString ].	source := aString.	source := eachSelector == #~~ ifTrue: [		'_gsReservedSelector_tilde_tilde_:' , (source copyFrom: 3 to: source size)	] ifFalse: [eachSelector == #== ifTrue: [		'_gsReservedSelector_equal_equal_:' , (source copyFrom: 3 to: source size)	] ifFalse: [		'_gsReservedSelector_' , source.	]].	source := source , Character lf asString , Character tab asString , 		'"The above Pharo code attempts to compile a reserved selector so we place it here for reference"' , 		Character lf asString.	^source	! !!PharoGsExport methodsFor: 'methods' stamp: 'JamesFoster 7/16/2019 10:27'!reservedSelectors 	^#(		__inProtectedMode _and: _downTo:by:do: _downTo:do: _gsReturnNothingEnableEvents		_gsReturnNoResult _isArray _isExceptionClass _isExecBlock _isFloat _isInteger		_isNumber _isOneByteString _isRange _isRegexp _isRubyHash _isScaledDecimal		_isSmallInteger _isSymbol _leaveProtectedMode _or: _stringCharSize ~~		and: == ifFalse: ifFalse:ifTrue: ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: ifTrue:		ifTrue:ifFalse: isKindOf: or: timesRepeat: to:by:do: to:do: untilFalse untilFalse: untilTrue		untilTrue: whileFalse whileFalse: whileTrue whileTrue: repeat	)! !!PharoGsExport methodsFor: 'methods' stamp: 'JamesFoster 7/16/2019 12:02'!addMethodsFor: eachBehavior	| count methodDict organization  |	count := 0.	methodDict := eachBehavior methodDict.	organization := eachBehavior organization.	methodDict keys asSortedCollection do: [ :eachSelector | 		| category source |		category := organization categoryOfElement: eachSelector.		source := self replaceCrWithLfIn: (methodDict at: eachSelector) sourceCode.		source := self rewritePrimitiveIn: source.		source := self rewriteReservedSelectorsIn: source selector: eachSelector.		source := self fixBinarySelectorsInLiteralArrayIn: source.		source := self 			fixMethodsThatWillNotCompileInBehavior: eachBehavior			selector: eachSelector 			source: source.					"special handling for Semaphore"		eachBehavior == Semaphore ifTrue: [			source := source 				copyReplaceAll: 'excessSignals'				with: 'signalCount'.		].					"method category and instance or class side"		fileStream lf;			nextPutAll: 'category: '''; nextPutAll: category; nextPut: $'; lf;			nextPutAll: (eachBehavior isMeta ifTrue: ['classMethod: '] ifFalse: ['method: ']); lf.			"put out the method"		(source substrings: (Array with: Character lf)) do: [:eachLine | 			| line |			line := eachLine , ' '.			(eachLine notEmpty and: [eachLine first == $%]) ifTrue: [fileStream space].			eachBehavior == Class ifTrue: [	"can't use instVarNames as method argument"				line := line copyReplaceAll: ' instVarNames ' with: ' instVarNameList '.			].			fileStream nextPutAll: line; lf.		].		fileStream nextPut: $%; lf.		count := count + 1.	].	^count! !!PharoGsExport methodsFor: 'methods' stamp: 'JamesFoster 7/16/2019 10:33'!fixMethodsThatWillNotCompileInBehavior: behavior selector: selector source: source	| compileErrors flag i |	compileErrors := #(		#(#MethodDictionary $*)		#(#Pragma #selector)		#(#Pragma #selector:)		#(#ProtoObjectTest $*)		#('SmallInteger class' #maxVal)		#('SmallInteger class' #minVal)		#('SmallInteger class' #startUp:)	).	flag := compileErrors anySatisfy: [:pair | 		(pair first == $* or: [pair first = behavior name]) 		and: [pair last == $* or: [pair last == selector]]].	flag ifFalse: [ ^source ].	i :=  source indexOf: Character lf.	^(source copyFrom: 1 to: i - 1), Character lf asString , 		'	<PharoCompileError>' , Character lf asString , '"' , 		((source copyFrom: i to: source size) copyReplaceAll: '"' with: '""') , '"'! !!PharoGsExport methodsFor: 'methods' stamp: 'JamesFoster 7/16/2019 12:04'!addClassCommentFor: aClass	"for GemStone classes, add a class-side #'pharoComment' method"	(self pharoToGsClassMap keys includes: aClass) ifTrue: [		fileStream			nextPutAll: 'set compile_env: 2'; lf;			nextPutAll: 'category: ''GemStone'''; lf;			nextPutAll: 'classMethod:'; lf;			nextPutAll: 'pharoComment'; lf;			nextPut: $^; 			print: (self replaceCrWithLfIn: aClass comment); lf;			nextPut: $%; lf;			yourself.		] ifFalse: [				"for Pharo classes, add the comment"		fileStream			nextPutAll: 'run'; lf;			nextPutAll: '(Smalltalk at: #'; nextPutAll: aClass name;			nextPutAll: ') comment: '; lf;			print: (self replaceCrWithLfIn: aClass comment); lf;			nextPut: $%; lf;			nextPutAll: 'set compile_env: 2'; lf;			yourself.	].	! !!PharoGsExport methodsFor: 'methods' stamp: 'JamesFoster 7/16/2019 10:54'!addMethodsHeaderFor: aClass	fileStream		nextPutAll: 'output push output/';		nextPutAll: aClass name;		nextPutAll: '.out only'; lf;		nextPutAll: 'errorCount'; lf;		nextPutAll: 'set compile_env: 0'; lf;		nextPutAll: 'run'; lf;		nextPutAll: 'Smalltalk at: #'; nextPutAll: aClass name; lf;		nextPut: $%; lf;		nextPutAll: 'set class **'; lf;		yourself.! !